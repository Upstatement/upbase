/// Given the location of a webfont, will generate a font-face declaration with multiple file formats.
/// @access public
/// @param {String} $font-name - Font family name
/// @param {String} $file-name - File name (no extension)
/// @param {String | Number} $weight [normal] - Font weight
/// @param {String} $style [normal] - Font style
/// @example scss - Usage
///   @include font-face('gotham', '/fonts/gotham');
@mixin font-face($font-name, $file-name, $weight: normal, $style: normal) {
  @font-face {
    font-family: quote($font-name);
    src: url($file-name + '.eot');
    src: url($file-name + '.eot?#iefix')  format('embedded-opentype'),
         url($file-name + '.woff') format('woff'),
         url($file-name + '.ttf')  format('truetype'),
         url($file-name + '.svg##{$font-name}')  format('svg');
    font-weight: $weight;
    font-style: $style;
  }
}

/// Given a font size in pixels, reproduces that font size in rems.
/// @access public
/// @param {Length} $size - Font size
/// @example scss - Usage
///   .foo {
///     @include font-size(16px);
///   }
/// @example css - Result
///   .foo {
///     font-size: 16px;
///     font-size: 1rem;
///   }
@mixin font-size($size) {
  @if unitless($size) {
    $size: $size * 1px;
  }

  font-size: $size;
  font-size: ($size / $base-font-size) * 1rem;
}

/// Forces browsers to use hardware acceleration for transforms
/// @access public
/// @example scss - Usage
///   .foo {
///     @include ha;
///   }
/// @example css - Result
///   .foo {
///     -webkit-transform: translate3d(0, 0, 0);
///     -moz-transform: translate3d(0, 0, 0);
///     transform: translate3d(0, 0, 0);
///   }
@mixin ha {
    @include prefix(transform, translate3d(0, 0, 0), 'webkit' 'ms');
}

/// Generates line-height values in both pixels and rems.
/// @access public
/// @param {Number} $height-value [12] - Height value
/// @example scss - Usage
///   .foo {
///     @include line-height(16);
///   }
/// @example css - Result
///   .foo {
///     line-height: 16px;
///     line-height: 1rem;
///   }
@mixin line-height($height-value: 12) {
    line-height: $height-value * 1px; //fallback for old browsers
    line-height: (1 / ($base-font-size / ($base-font-size * 0 + 1)) * $height-value * 1rem);
}


/// Shorthandizes position declarations.
/// @access public
/// @param {String} $type - Either `relative`, `absolute` or `fixed`
/// @param {Length} $left [null] - Left offset
/// @param {Length} $right [null] - Right offset
/// @param {Length} $top [null] - Top offset
/// @param {Length} $bottom [null] - Bottom offset
/// @example scss - Usage
///   .foo {
///     @include position(absolute, $top: 10px, $left: 10px);
///   }
/// @example css - Result
///   .foo {
///     position: absolute;
///     left: 10px;
///     top: 10px;
///   }
@mixin position($type, $top: null, $right: null, $bottom: null, $left: null) {
    position: $type;
    top: $top;
    right: $right;
    bottom: $bottom;
    left: $left;
}



// Black and white function ideas
// But this should use the shade/tint function
// instead of be opacity-based
// We might have had these in Upbase before?

@function black($opacity) {
    @return rgba(0, 0, 0, $opacity);
}
@function white($opacity) {
    @return rgba(255, 255, 255, $opacity);
}



//apply a border style to whichever sides you want to

@mixin scut-border (
  $style,
  $sides: n y
) {

  @if length($sides) == 2 {
    @if nth($sides, 1) != n {
      border-top: $style;
      border-bottom: $style;
    }
    @if nth($sides, 2) != n {
      border-left: $style;
      border-right: $style;
    }
  }

  @else if length($sides) == 4 {
    @if nth($sides, 1) != n {
      border-top: $style;
    }
    @if nth($sides, 2) != n {
      border-right: $style;
    }
    @if nth($sides, 3) != n {
      border-bottom: $style;
    }
    @if nth($sides, 4) != n {
      border-left: $style;
    }
  }

  @else {
    @warn "Scut-border requires a $sides argument of 2 or 4 values.";
  }

}


// Use rems instead of pxs with a fallback for anything
// scut-rem-fallback(30 50px 0 25px, margin);
@mixin scut-rem-fallback (
  $pixels,
  $property: font-size
) {

  $px-vals: null;
  @each $val in $pixels {
    $val-in-px: scut-strip-unit($val) * 1px;
    $px-vals: append($px-vals, $val-in-px);
  }
  $rem-vals: scut-rem($pixels);

  #{$property}: $px-vals;
  #{$property}: $rem-vals;

}


//hanging indent
@mixin scut-hanging-indent (
  $indent: 1em
) {

  // padding-left creates the indent,
  // while text-indent pulls the first line
  // back to the edge.

  padding-left: $indent;
  text-indent: -$indent;

}
